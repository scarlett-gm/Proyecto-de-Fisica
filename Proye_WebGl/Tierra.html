<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Tierra con Campos Magnéticos Realistas</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #000;
      font-family: Arial, sans-serif;
    }
    canvas { 
      display: block; 
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: white;
      pointer-events: none;
      text-shadow: 0 0 5px rgba(0,0,0,0.8);
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 1.2em;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="info">Tierra con Campos Magnéticos • Rotación: Click + Arrastrar • Zoom: Rueda del ratón</div>
  <div id="loading">Cargando modelo 3D...</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  
  <script>
    // Variables globales
    let scene, camera, renderer, earth, controls, fieldLines = [];
    const clock = new THREE.Clock();
    
    init();
    animate();

    function init() {
      // 1. Configuración básica
      setupScene();
      setupCamera();
      setupRenderer();
      setupControls();
      setupLights();

      // 2. Crear Tierra
      createEarth();

      // 3. Crear campos magnéticos mejorados
      createImprovedMagneticFields();

      // 4. Manejo de eventos
      setupEvents();

      document.getElementById('loading').style.display = 'none';
    }

    function setupScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000033);
      scene.fog = new THREE.FogExp2(0x000033, 0.001);
    }

    function setupCamera() {
      camera = new THREE.PerspectiveCamera(
        60, 
        window.innerWidth / window.innerHeight, 
        0.1, 
        1000
      );
      camera.position.z = 4;
    }

    function setupRenderer() {
      renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
    }

    function setupControls() {
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 2;
      controls.maxDistance = 8;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;
    }

    function setupLights() {
      // Luz ambiental
      scene.add(new THREE.AmbientLight(0x404040, 0.5));
      
      // Luz direccional principal (sol)
      const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
      sunLight.position.set(5, 3, 5);
      scene.add(sunLight);
      
      // Luz de relleno
      const fillLight = new THREE.DirectionalLight(0x8899ff, 0.3);
      fillLight.position.set(-5, -1, -3);
      scene.add(fillLight);
    }

    function createEarth() {
      const geometry = new THREE.SphereGeometry(1, 64, 64);
      
      // Texturas
      const textureLoader = new THREE.TextureLoader();
      const texture = textureLoader.load(
        'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg',
        () => renderer.render(scene, camera)
      );
      const bumpMap = textureLoader.load(
        'https://threejs.org/examples/textures/planets/earth_normal_2048.jpg'
      );
      const specularMap = textureLoader.load(
        'https://threejs.org/examples/textures/planets/earth_specular_2048.jpg'
      );
      
      const material = new THREE.MeshPhongMaterial({
        map: texture,
        bumpMap: bumpMap,
        bumpScale: 0.05,
        specularMap: specularMap,
        specular: new THREE.Color('grey'),
        shininess: 5
      });
      
      earth = new THREE.Mesh(geometry, material);
      scene.add(earth);
      
      // Añadir atmósfera
      createAtmosphere();
    }

    function createAtmosphere() {
      const geometry = new THREE.SphereGeometry(1.05, 64, 64);
      const material = new THREE.MeshStandardMaterial({
        color: 0x5599ff,
        transparent: true,
        opacity: 0.15,
        side: THREE.BackSide
      });
      const atmosphere = new THREE.Mesh(geometry, material);
      earth.add(atmosphere);
    }

    function createImprovedMagneticFields() {
      const group = new THREE.Group();
      const count = 24; // Número de líneas de campo
      
      // Material para líneas que salen (azul)
      const outgoingMaterial = new THREE.LineBasicMaterial({
        color: 0x00aaff,
        transparent: true,
        opacity: 0.8,
        linewidth: 1.5
      });
      
      // Material para líneas que entran (rojo)
      const incomingMaterial = new THREE.LineBasicMaterial({
        color: 0xff5555,
        transparent: true,
        opacity: 0.8,
        linewidth: 1.5
      });
      
      // Crear líneas de campo magnético
      for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2;
        
        // Línea que sale del polo norte (azul)
        const outgoingCurve = createFieldCurve(angle, 1.8, true);
        const outgoingPoints = outgoingCurve.getPoints(50);
        const outgoingGeometry = new THREE.BufferGeometry().setFromPoints(outgoingPoints);
        const outgoingLine = new THREE.Line(outgoingGeometry, outgoingMaterial);
        group.add(outgoingLine);
        fieldLines.push(outgoingLine);
        
        // Línea que entra al polo sur (rojo)
        const incomingCurve = createFieldCurve(angle, 1.8, false);
        const incomingPoints = incomingCurve.getPoints(50);
        const incomingGeometry = new THREE.BufferGeometry().setFromPoints(incomingPoints);
        const incomingLine = new THREE.Line(incomingGeometry, incomingMaterial);
        group.add(incomingLine);
        fieldLines.push(incomingLine);
      }
      
      scene.add(group);
      
      // Añadir efectos en los polos
      createPoleEffects();
    }

    function createFieldCurve(angle, radius, isOutgoing) {
      const startY = isOutgoing ? -0.2 : 0.2;
      const endY = isOutgoing ? 1.5 : -1.5;
      const controlY = isOutgoing ? 0.5 : -0.5;
      const curveFactor = isOutgoing ? 1 : -1;
      
      const start = new THREE.Vector3(
        Math.cos(angle) * 0.2,
        startY,
        Math.sin(angle) * 0.2
      );
      
      const control = new THREE.Vector3(
        Math.cos(angle) * radius * 0.7,
        controlY,
        Math.sin(angle) * radius * 0.7
      );
      
      const end = new THREE.Vector3(
        Math.cos(angle + curveFactor * 0.3) * radius * 0.3,
        endY,
        Math.sin(angle + curveFactor * 0.3) * radius * 0.3
      );
      
      return new THREE.QuadraticBezierCurve3(start, control, end);
    }

    function createPoleEffects() {
      // Efecto en polo norte (azul)
      const northPoleGeometry = new THREE.SphereGeometry(0.1, 32, 32);
      const northPoleMaterial = new THREE.MeshBasicMaterial({
        color: 0x00aaff,
        transparent: true,
        opacity: 0.7
      });
      const northPole = new THREE.Mesh(northPoleGeometry, northPoleMaterial);
      northPole.position.y = 1;
      earth.add(northPole);
      
      // Efecto en polo sur (rojo)
      const southPoleGeometry = new THREE.SphereGeometry(0.1, 32, 32);
      const southPoleMaterial = new THREE.MeshBasicMaterial({
        color: 0xff5555,
        transparent: true,
        opacity: 0.7
      });
      const southPole = new THREE.Mesh(southPoleGeometry, southPoleMaterial);
      southPole.position.y = -1;
      earth.add(southPole);
      
      // Añadir partículas brillantes
      createParticles();
    }

    function createParticles() {
      const particleCount = 100;
      const particles = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      
      for (let i = 0; i < particleCount; i++) {
        // Posiciones aleatorias alrededor de los polos
        const isNorth = Math.random() > 0.5;
        const radius = 0.2 + Math.random() * 0.3;
        const angle = Math.random() * Math.PI * 2;
        
        positions[i * 3] = Math.cos(angle) * radius;
        positions[i * 3 + 1] = (isNorth ? 0.8 : -0.8) + (Math.random() - 0.5) * 0.2;
        positions[i * 3 + 2] = Math.sin(angle) * radius;
        
        // Colores según el polo
        if (isNorth) {
          colors[i * 3] = 0.0; // R
          colors[i * 3 + 1] = 0.5 + Math.random() * 0.5; // G
          colors[i * 3 + 2] = 1.0; // B
        } else {
          colors[i * 3] = 1.0; // R
          colors[i * 3 + 1] = 0.2 + Math.random() * 0.3; // G
          colors[i * 3 + 2] = 0.2 + Math.random() * 0.3; // B
        }
        
        sizes[i] = 2 + Math.random() * 3;
      }
      
      particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      
      const particleMaterial = new THREE.PointsMaterial({
        size: 0.1,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
      });
      
      const particleSystem = new THREE.Points(particles, particleMaterial);
      earth.add(particleSystem);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      const time = clock.getElapsedTime();
      
      // Rotación de la Tierra
      if (earth) {
        earth.rotation.y += 0.2 * delta;
      }
      
      // Animación de las líneas de campo
      fieldLines.forEach((line, index) => {
        if (line.geometry.attributes.position) {
          const positions = line.geometry.attributes.position.array;
          for (let i = 1; i < positions.length / 3 - 1; i++) {
            // Efecto de onda suave
            positions[i * 3 + 1] += Math.sin(time * 2 + index * 0.2 + i * 0.1) * 0.005;
          }
          line.geometry.attributes.position.needsUpdate = true;
        }
      });
      
      controls.update();
      renderer.render(scene, camera);
    }

    function setupEvents() {
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }
  </script>
</body>
</html>